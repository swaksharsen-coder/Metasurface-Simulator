<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Metasurface 10×10 Far-Field Simulator (6 Polarizations)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    h1, h2, h3 {
      margin-top: 1.2em;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 20px;
    }
    .panel {
      border: 1px solid #ccc;
      padding: 10px;
      flex: 1 1 300px;
      min-width: 280px;
    }
    textarea {
      width: 100%;
      height: 120px;
      font-family: monospace;
      font-size: 12px;
    }
    input[type="text"] {
      width: 100%;
    }
    button {
      padding: 8px 14px;
      margin-top: 10px;
      cursor: pointer;
    }
    table {
      border-collapse: collapse;
      font-size: 11px;
    }
    th, td {
      border: 1px solid #aaa;
      padding: 2px 4px;
      text-align: right;
    }
    .heatmap-container {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .heatmap-block {
      text-align: center;
    }
    canvas {
      border: 1px solid #aaa;
    }
    .note {
      font-size: 11px;
      color: #555;
    }
  </style>
</head>
<body>
  <h1>Metasurface 10×10 Far-Field Simulator (6 Polarizations)</h1>
  <p>
    Paste your 24×24 library (<strong>φx, φy, Tx, Ty</strong>) and your 10×10 metasurface design
    (<strong>L, W, θ</strong>), choose an input polarization, then click
    <strong>Run Simulation</strong>.
  </p>

  <div class="row">
    <div class="panel">
      <h2>Library (24×24)</h2>
      <p class="note">
        Each textarea expects 24 rows, each row 24 numbers separated by spaces/tabs.
        Angles in <b>radians</b>, transmissions 0–1.
      </p>
      <label>Ex Phase φx (24×24):</label>
      <textarea id="phiX_2D" placeholder="Row1: 3.98 4.01 ...&#10;Row2: ..."></textarea>

      <label>Ey Phase φy (24×24):</label>
      <textarea id="phiY_2D" placeholder="Row1: 3.98 4.01 ..."></textarea>

      <label>Tx (Ex transmission) (24×24):</label>
      <textarea id="Tx_2D" placeholder="Row1: 0.96 0.96 ..."></textarea>

      <label>Ty (Ey transmission) (24×24):</label>
      <textarea id="Ty_2D" placeholder="Row1: 0.96 0.96 ..."></textarea>

      <label>Length grid (nm) (1×24, default 50:10:280):</label>
      <input id="L_list" type="text" value="50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280" />

      <label>Width grid (nm) (1×24, default 50:10:280):</label>
      <input id="W_list" type="text" value="50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280" />
    </div>

    <div class="panel">
      <h2>Metasurface Design (10×10)</h2>
      <p class="note">
        Each textarea expects 10 rows, each row 10 numbers (nm or degrees) separated by spaces/tabs.
      </p>

      <label>L design (nm) (10×10):</label>
      <textarea id="L_design" placeholder="L[0,0] L[0,1] ... L[0,9]&#10;...&#10;L[9,0] ... L[9,9]"></textarea>

      <label>W design (nm) (10×10):</label>
      <textarea id="W_design" placeholder="W[0,0] W[0,1] ... W[0,9]&#10;...&#10;W[9,0] ... W[9,9]"></textarea>

      <label>θ design (deg) (10×10) – rotation of each pillar:</label>
      <textarea id="Theta_design" placeholder="Theta[0,0] ... Theta[0,9]&#10;...&#10;Theta[9,0] ... Theta[9,9]"></textarea>

      <label>Input Polarization:</label>
      <select id="polarization">
        <option value="Ex">Ex (H)</option>
        <option value="Ey">Ey (V)</option>
        <option value="P45">+45°</option>
        <option value="M45">-45°</option>
        <option value="RCP">RCP</option>
        <option value="LCP">LCP</option>
      </select>

      <button onclick="runSimulation()">Run Simulation</button>

      <p id="energyInfo" class="note"></p>
    </div>
  </div>

  <h2>Far Field Over Diffraction Orders m,n ∈ [-8 .. +8]</h2>
  <p class="note">
    Intensities are normalized so that the sum over all (m,n) = 1 (energy normalized).<br/>
    We show three maps: total |Ex|²+|Ey|², Ex-only, Ey-only.
  </p>

  <div class="heatmap-container">
    <div class="heatmap-block">
      <h3>Total Intensity</h3>
      <canvas id="canvasTotal" width="250" height="250"></canvas>
      <div id="tableTotal"></div>
    </div>
    <div class="heatmap-block">
      <h3>Ex Channel</h3>
      <canvas id="canvasEx" width="250" height="250"></canvas>
      <div id="tableEx"></div>
    </div>
    <div class="heatmap-block">
      <h3>Ey Channel</h3>
      <canvas id="canvasEy" width="250" height="250"></canvas>
      <div id="tableEy"></div>
    </div>
  </div>

  <script>
    // ======== Utility: parse whitespace-separated matrix text into 2D array ========
    function parseMatrix(text, expectedRows, expectedCols) {
      const lines = text.trim().split(/\r?\n/).filter(l => l.trim().length > 0);
      if (expectedRows && lines.length !== expectedRows) {
        throw new Error("Expected " + expectedRows + " rows, got " + lines.length);
      }
      const mat = [];
      for (let r = 0; r < lines.length; r++) {
        const parts = lines[r].trim().split(/[\s,]+/).filter(x => x.length > 0);
        if (expectedCols && parts.length !== expectedCols) {
          throw new Error("Row " + (r+1) + " expected " + expectedCols + " columns, got " + parts.length);
        }
        mat.push(parts.map(Number));
      }
      return mat;
    }

    function parseVector(text, expectedLen) {
      const parts = text.trim().split(/[\s,]+/).filter(x => x.length > 0);
      if (expectedLen && parts.length !== expectedLen) {
        throw new Error("Expected " + expectedLen + " entries, got " + parts.length);
      }
      return parts.map(Number);
    }

    function findIndexForValue(list, val) {
      // exact match, or nearest
      let bestIdx = 0;
      let bestDiff = Math.abs(list[0] - val);
      for (let i = 1; i < list.length; i++) {
        const d = Math.abs(list[i] - val);
        if (d < bestDiff) {
          bestDiff = d;
          bestIdx = i;
        }
      }
      return bestIdx;
    }

    // ======== Build output fields including rotation θ ========
    // Returns {Ex: Nx×Ny complex, Ey: Nx×Ny complex}
    function buildFields(library, design, pol) {
      const { phiX_2D, phiY_2D, Tx_2D, Ty_2D, L_LIST, W_LIST } = library;
      const { L_design, W_design, Theta_design } = design;

      const Nx = 10;
      const Ny = 10;

      const Ex = Array.from({ length: Nx }, () =>
        Array.from({ length: Ny }, () => ({ re: 0, im: 0 }))
      );
      const Ey = Array.from({ length: Nx }, () =>
        Array.from({ length: Ny }, () => ({ re: 0, im: 0 }))
      );

      const invRoot2 = 1 / Math.sqrt(2);

      for (let p = 0; p < Nx; p++) {
        for (let q = 0; q < Ny; q++) {
          const L_nm = L_design[p][q];
          const W_nm = W_design[p][q];

          const iL = findIndexForValue(L_LIST, L_nm);
          const jW = findIndexForValue(W_LIST, W_nm);

          const phiX = phiX_2D[iL][jW];
          const phiY = phiY_2D[iL][jW];
          const Tx = Tx_2D[iL][jW];
          const Ty = Ty_2D[iL][jW];

          // Input Jones vector
          let Ex_in_re = 0, Ex_in_im = 0;
          let Ey_in_re = 0, Ey_in_im = 0;

          if (pol === "Ex") {
            Ex_in_re = 1;
          } else if (pol === "Ey") {
            Ey_in_re = 1;
          } else if (pol === "P45") {
            Ex_in_re = invRoot2;
            Ey_in_re = invRoot2;
          } else if (pol === "M45") {
            Ex_in_re = invRoot2;
            Ey_in_re = -invRoot2;
          } else if (pol === "RCP") {
            // (1/√2)[1, -i]
            Ex_in_re = invRoot2;
            Ey_in_im = -invRoot2;
          } else if (pol === "LCP") {
            // (1/√2)[1, +i]
            Ex_in_re = invRoot2;
            Ey_in_im = invRoot2;
          }

          // Rotation θ
          const theta_deg = Theta_design[p][q] || 0;
          const theta = theta_deg * Math.PI / 180;
          const c = Math.cos(theta);
          const s = Math.sin(theta);

          // 1) Rotate input to local frame: E_local = R(θ)*E_in
          const Ex_loc_re =  c * Ex_in_re - s * Ey_in_re;
          const Ey_loc_re =  s * Ex_in_re + c * Ey_in_re;

          const Ex_loc_im =  c * Ex_in_im - s * Ey_in_im;
          const Ey_loc_im =  s * Ex_in_im + c * Ey_in_im;

          // 2) Apply diagonal diag(Tx e^{iφx}, Ty e^{iφy}) in local frame
          const cx = Math.cos(phiX), sx = Math.sin(phiX);
          const cy = Math.cos(phiY), sy = Math.sin(phiY);

          const Ex_loc_out_re = Tx * (Ex_loc_re * cx - Ex_loc_im * sx);
          const Ex_loc_out_im = Tx * (Ex_loc_re * sx + Ex_loc_im * cx);

          const Ey_loc_out_re = Ty * (Ey_loc_re * cy - Ey_loc_im * sy);
          const Ey_loc_out_im = Ty * (Ey_loc_re * sy + Ey_loc_im * cy);

          // 3) Rotate back to lab frame: E_out = R(-θ)*E_loc_out
          const Ex_out_re =  c * Ex_loc_out_re + s * Ey_loc_out_re;
          const Ey_out_re = -s * Ex_loc_out_re + c * Ey_loc_out_re;

          const Ex_out_im =  c * Ex_loc_out_im + s * Ey_loc_out_im;
          const Ey_out_im = -s * Ex_loc_out_im + c * Ey_loc_out_im;

          Ex[p][q] = { re: Ex_out_re, im: Ex_out_im };
          Ey[p][q] = { re: Ey_out_re, im: Ey_out_im };
        }
      }

      return { Ex, Ey };
    }

    // ======== Compute far field via discrete FT over orders m,n in [-M..M] ========
    function computeFarField(Ex, Ey, M) {
      const Nx = Ex.length;
      const Ny = Ex[0].length;
      const size = 2 * M + 1;

      const I_total = Array.from({ length: size }, () => Array(size).fill(0));
      const I_Ex    = Array.from({ length: size }, () => Array(size).fill(0));
      const I_Ey    = Array.from({ length: size }, () => Array(size).fill(0));

      const normFactor = 1 / Math.sqrt(Nx * Ny);

      // Real-space power (Parseval check)
      let P_real = 0;
      for (let p = 0; p < Nx; p++) {
        for (let q = 0; q < Ny; q++) {
          const Expq = Ex[p][q];
          const Eypq = Ey[p][q];
          const mag2_Ex = Expq.re * Expq.re + Expq.im * Expq.im;
          const mag2_Ey = Eypq.re * Eypq.re + Eypq.im * Eypq.im;
          P_real += mag2_Ex + mag2_Ey;
        }
      }

      for (let mi = -M; mi <= M; mi++) {
        for (let ni = -M; ni <= M; ni++) {
          let Exk_re = 0, Exk_im = 0;
          let Eyk_re = 0, Eyk_im = 0;

          for (let p = 0; p < Nx; p++) {
            for (let q = 0; q < Ny; q++) {
              const Expq = Ex[p][q];
              const Eypq = Ey[p][q];

              const phase = -2 * Math.PI * (mi * p / Nx + ni * q / Ny);
              const cp = Math.cos(phase), sp = Math.sin(phase);

              // Multiply Ex(p,q) * e^{i phase}
              const Ex_re_tmp = Expq.re * cp - Expq.im * sp;
              const Ex_im_tmp = Expq.re * sp + Expq.im * cp;

              const Ey_re_tmp = Eypq.re * cp - Eypq.im * sp;
              const Ey_im_tmp = Eypq.re * sp + Eypq.im * cp;

              Exk_re += Ex_re_tmp;
              Exk_im += Ex_im_tmp;
              Eyk_re += Ey_re_tmp;
              Eyk_im += Ey_im_tmp;
            }
          }

          Exk_re *= normFactor;
          Exk_im *= normFactor;
          Eyk_re *= normFactor;
          Eyk_im *= normFactor;

          const mag2_Ex = Exk_re * Exk_re + Exk_im * Exk_im;
          const mag2_Ey = Eyk_re * Eyk_re + Eyk_im * Eyk_im;
          const mag2_tot = mag2_Ex + mag2_Ey;

          const i = mi + M;
          const j = ni + M;
          I_Ex[i][j] = mag2_Ex;
          I_Ey[i][j] = mag2_Ey;
          I_total[i][j] = mag2_tot;
        }
      }

      // Normalize so sum(I_total) = 1
      let P_k = 0;
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          P_k += I_total[i][j];
        }
      }
      if (P_k > 0) {
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            I_total[i][j] /= P_k;
            I_Ex[i][j]    /= P_k;
            I_Ey[i][j]    /= P_k;
          }
        }
      }

      return { I_total, I_Ex, I_Ey, P_real, P_k };
    }

    // ======== Render numeric table ========
    function renderTable(intensity, elementId, M) {
      const size = intensity.length;
      let html = "<table><tr><th>m\\n</th>";
      for (let n = -M; n <= M; n++) {
        html += "<th>" + n + "</th>";
      }
      html += "</tr>";
      for (let i = 0; i < size; i++) {
        const m = i - M;
        html += "<tr><th>" + m + "</th>";
        for (let j = 0; j < size; j++) {
          const val = intensity[i][j];
          html += "<td>" + val.toFixed(3) + "</td>";
        }
        html += "</tr>";
      }
      html += "</table>";
      document.getElementById(elementId).innerHTML = html;
    }

    // ======== Render simple heatmap on canvas ========
    function renderHeatmap(intensity, canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext("2d");
      const size = intensity.length;
      const w = canvas.width;
      const h = canvas.height;
      const cellW = w / size;
      const cellH = h / size;

      // find max for scaling (after normalization sum=1, but distribution may be peaked)
      let maxVal = 0;
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (intensity[i][j] > maxVal) maxVal = intensity[i][j];
        }
      }
      if (maxVal === 0) {
        ctx.clearRect(0, 0, w, h);
        return;
      }

      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const v = intensity[i][j] / maxVal; // 0..1
          // grayscale: 0 -> white, 1 -> black
          const shade = Math.round(255 * (1 - v));
          ctx.fillStyle = "rgb(" + shade + "," + shade + "," + shade + ")";
          ctx.fillRect(j * cellW, i * cellH, cellW, cellH);
        }
      }
    }

    // ======== Main: run simulation ========
    function runSimulation() {
      try {
        const phiX_2D = parseMatrix(document.getElementById("phiX_2D").value, 24, 24);
        const phiY_2D = parseMatrix(document.getElementById("phiY_2D").value, 24, 24);
        const Tx_2D   = parseMatrix(document.getElementById("Tx_2D").value,   24, 24);
        const Ty_2D   = parseMatrix(document.getElementById("Ty_2D").value,   24, 24);

        const L_LIST  = parseVector(document.getElementById("L_list").value, 24);
        const W_LIST  = parseVector(document.getElementById("W_list").value, 24);

        const L_design = parseMatrix(document.getElementById("L_design").value, 10, 10);
        const W_design = parseMatrix(document.getElementById("W_design").value, 10, 10);
        const Theta_design = parseMatrix(document.getElementById("Theta_design").value, 10, 10);

        const pol = document.getElementById("polarization").value;

        const library = { phiX_2D, phiY_2D, Tx_2D, Ty_2D, L_LIST, W_LIST };
        const design  = { L_design, W_design, Theta_design };

        const { Ex, Ey } = buildFields(library, design, pol);

        const M = 8; // diffraction order range
        const { I_total, I_Ex, I_Ey, P_real, P_k } = computeFarField(Ex, Ey, M);

        // Energy check info
        const info = `
Real-space power Σ|E|² = ${P_real.toFixed(4)},
k-space power ΣI = 1 (normalized),
(unnormalized ΣI would be ≈ ${P_k.toFixed(4)}).
        `;
        document.getElementById("energyInfo").textContent = info;

        // Render tables
        renderTable(I_total, "tableTotal", M);
        renderTable(I_Ex,    "tableEx",    M);
        renderTable(I_Ey,    "tableEy",    M);

        // Render heatmaps
        renderHeatmap(I_total, "canvasTotal");
        renderHeatmap(I_Ex,    "canvasEx");
        renderHeatmap(I_Ey,    "canvasEy");

      } catch (err) {
        alert("Error: " + err.message);
        console.error(err);
      }
    }
  </script>
</body>
</html>
