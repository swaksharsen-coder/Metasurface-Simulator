<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Metasurface Far-Field Simulator (10×10 from Dimensions)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 16px;
      background: #f5f5f5;
    }
    h1, h2, h3 {
      margin-top: 12px;
      margin-bottom: 6px;
    }
    .section {
      background: #ffffff;
      padding: 12px;
      margin-bottom: 16px;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }
    textarea {
      width: 100%;
      min-height: 80px;
      font-family: Consolas, monospace;
      font-size: 12px;
      white-space: pre;
    }
    label {
      font-weight: bold;
      display: block;
      margin-top: 6px;
      margin-bottom: 2px;
    }
    button {
      margin: 4px 4px 4px 0;
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #999;
      background: #eee;
      cursor: pointer;
    }
    button:hover { background: #ddd; }
    #heatmap {
      border: 1px solid #444;
      margin-top: 8px;
    }
    table {
      border-collapse: collapse;
      margin-top: 8px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 2px 4px;
      font-size: 11px;
      text-align: right;
    }
    .status {
      font-size: 12px;
      color: #333;
      margin-top: 4px;
    }
    .small-input { width: 80px; }
    .row-flex {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .col {
      flex: 1;
      min-width: 260px;
    }
    select {
      padding: 3px 6px;
      margin-left: 4px;
    }
  </style>
</head>
<body>
  <h1>Metasurface Far-Field Simulator (10×10 from Length/Width/Rotation)</h1>

  <!-- ============ 1. LIBRARY ============ -->
  <div class="section">
    <h2>1. 400 nm Library (24×24) — φx, φy, Tx, Ty</h2>
    <p>Paste your 24×24 matrices (24 lines × 24 numbers each). Grid assumed: L,W = 50:10:280 nm.</p>

    <div class="row-flex">
      <div class="col">
        <label for="libPhiX">φx (Ex phase, rad, 24×24)</label>
        <textarea id="libPhiX"></textarea>
      </div>
      <div class="col">
        <label for="libPhiY">φy (Ey phase, rad, 24×24)</label>
        <textarea id="libPhiY"></textarea>
      </div>
    </div>

    <div class="row-flex">
      <div class="col">
        <label for="libTx">Tx (Ex amplitude, 0–1, 24×24)</label>
        <textarea id="libTx"></textarea>
      </div>
      <div class="col">
        <label for="libTy">Ty (Ey amplitude, 0–1, 24×24)</label>
        <textarea id="libTy"></textarea>
      </div>
    </div>
  </div>

  <!-- ============ 2. DESIGN ============ -->
  <div class="section">
    <h2>2. Metasurface Design (10×10) — Length, Width, Rotation</h2>
    <p>Paste your 10×10 maps (10 lines × 10 numbers each) for length, width and rotation.</p>

    <div class="row-flex">
      <div class="col">
        <label for="Lmap">Length L (nm, 10×10)</label>
        <textarea id="Lmap"></textarea>
      </div>
      <div class="col">
        <label for="Wmap">Width W (nm, 10×10)</label>
        <textarea id="Wmap"></textarea>
      </div>
    </div>
    <div class="row-flex">
      <div class="col">
        <label for="Rotmap">Rotation θ (deg, 10×10)</label>
        <textarea id="Rotmap"></textarea>
      </div>
    </div>
  </div>

  <!-- ============ 3. SIM SETTINGS ============ -->
  <div class="section">
    <h2>3. Simulation Settings</h2>

    <label>
      Input polarization:
      <select id="inputPol">
        <option value="Ex">Ex</option>
        <option value="Ey">Ey</option>
        <option value="P45">+45°</option>
        <option value="M45">−45°</option>
        <option value="RCP">RCP</option>
        <option value="LCP">LCP</option>
      </select>
    </label>

    <label>
      Max diffraction order |m|,|n|:
      <input id="maxOrder" type="number" value="8" class="small-input">
    </label>

    <button id="btnRun">Run Simulation</button>
    <div id="simStatus" class="status"></div>
  </div>

  <!-- ============ 4. RESULTS ============ -->
  <div class="section">
    <h2>4. Far-Field Results</h2>
    <p>Intensity normalized so that max over all (m,n) is 1.</p>
    <div id="onAxisInfo" class="status"></div>
    <canvas id="heatmap" width="400" height="400"></canvas>
    <div id="intensityTableContainer"></div>
  </div>

  <!-- ============ SCRIPT ============ -->
  <script>
    /********** Helpers: parse matrix **********/
    function parseMatrix(text, expectedRows, expectedCols) {
      const rows = text.trim().split(/[\r\n]+/).filter(r => r.trim().length > 0);
      if (rows.length !== expectedRows) {
        throw new Error("Expected " + expectedRows + " rows, got " + rows.length);
      }
      const mat = [];
      for (let i = 0; i < expectedRows; i++) {
        const parts = rows[i].trim().split(/[\s,]+/).filter(p => p.length > 0);
        if (parts.length !== expectedCols) {
          throw new Error("Row " + (i+1) + ": expected " + expectedCols + " columns, got " + parts.length);
        }
        mat[i] = parts.map(Number);
      }
      return mat;
    }

    /********** Simple complex numbers **********/
    function c(re, im) { return {re, im}; }
    function cAdd(a, b) { return {re: a.re + b.re, im: a.im + b.im}; }
    function cMul(a, b) {
      return {
        re: a.re*b.re - a.im*b.im,
        im: a.re*b.im + a.im*b.re
      };
    }
    function cExp(phi) {
      return {re: Math.cos(phi), im: Math.sin(phi)};
    }
    function cAbs2(a) { return a.re*a.re + a.im*a.im; }

    // a*b + c0
    function cAddMul(a, b, c0) {
      return cAdd(cMul(a,b), c0);
    }

    /********** Library + design getters **********/
    function getLibraryMatrices() {
      const phiX = parseMatrix(document.getElementById("libPhiX").value, 24, 24);
      const phiY = parseMatrix(document.getElementById("libPhiY").value, 24, 24);
      const Tx   = parseMatrix(document.getElementById("libTx").value,   24, 24);
      const Ty   = parseMatrix(document.getElementById("libTy").value,   24, 24);
      return { phiX, phiY, Tx, Ty };
    }

    function getDesignMatrices() {
      const Lmap   = parseMatrix(document.getElementById("Lmap").value,   10, 10);
      const Wmap   = parseMatrix(document.getElementById("Wmap").value,   10, 10);
      const Rotmap = parseMatrix(document.getElementById("Rotmap").value, 10, 10);
      return { Lmap, Wmap, Rotmap };
    }

    // Map (L,W) to nearest index in 50:10:280 grid
    function libIndexFromDimensions(L_nm, W_nm) {
      let i = Math.round((L_nm - 50) / 10);
      let j = Math.round((W_nm - 50) / 10);
      if (i < 0) i = 0; if (i > 23) i = 23;
      if (j < 0) j = 0; if (j > 23) j = 23;
      return { i, j };
    }

    /********** Per-pillar Jones and output fields **********/
    function computePillarFields(pol, library, design) {
      const Nx = 10, Ny = 10;
      const { phiX, phiY, Tx, Ty } = library;
      const { Lmap, Wmap, Rotmap } = design;

      // Input Jones vector (complex) for chosen polarization
      const invSqrt2 = 1/Math.sqrt(2);
      let Jin;
      switch (pol) {
        case "Ex":  Jin = [c(1,0), c(0,0)]; break;
        case "Ey":  Jin = [c(0,0), c(1,0)]; break;
        case "P45": Jin = [c(invSqrt2,0), c(invSqrt2,0)]; break;
        case "M45": Jin = [c(invSqrt2,0), c(-invSqrt2,0)]; break;
        case "RCP": Jin = [c(invSqrt2,0), c(0,-invSqrt2)]; break; // (1, -i)/√2
        case "LCP": Jin = [c(invSqrt2,0), c(0, invSqrt2)]; break; // (1,  i)/√2
        default:    Jin = [c(1,0), c(0,0)];
      }

      const Ex_out = [];
      const Ey_out = [];
      for (let px = 0; px < Nx; px++) {
        Ex_out[px] = new Array(Ny);
        Ey_out[px] = new Array(Ny);
        for (let py = 0; py < Ny; py++) {
          const L_nm = Lmap[px][py];
          const W_nm = Wmap[px][py];
          const theta_deg = Rotmap[px][py];

          const { i, j } = libIndexFromDimensions(L_nm, W_nm);
          const phx = phiX[i][j];
          const phy = phiY[i][j];
          const tx  = Tx[i][j];
          const ty  = Ty[i][j];

          // diag(tx e^{iφx}, ty e^{iφy})
          let jxx = cExp(phx); jxx.re *= tx; jxx.im *= tx;
          let jyy = cExp(phy); jyy.re *= ty; jyy.im *= ty;

          const theta = theta_deg * Math.PI / 180;
          const cth  = Math.cos(theta);
          const sth  = Math.sin(theta);
          const cthm = Math.cos(-theta);
          const sthm = Math.sin(-theta);

          // R(θ)
          const r11 = cth,  r12 = -sth;
          const r21 = sth,  r22 =  cth;

          // M = diag(jxx,jyy)*R(θ)
          const m11 = cMul(jxx, c(r11,0));
          const m12 = cMul(jxx, c(r12,0));
          const m21 = cMul(jyy, c(r21,0));
          const m22 = cMul(jyy, c(r22,0));

          // R(-θ)
          const rm11 = c(cthm,0), rm12 = c(-sthm,0);
          const rm21 = c(sthm,0), rm22 = c(cthm,0);

          // J = R(-θ)*M
          const J11 = cAddMul(rm11, m11, cMul(rm12, m21));
          const J12 = cAddMul(rm11, m12, cMul(rm12, m22));
          const J21 = cAddMul(rm21, m11, cMul(rm22, m21));
          const J22 = cAddMul(rm21, m12, cMul(rm22, m22));

          // E_out = J * Jin
          const Ex_in = Jin[0];
          const Ey_in = Jin[1];
          const Ex_tmp = cAddMul(J11, Ex_in, cMul(J12, Ey_in));
          const Ey_tmp = cAddMul(J21, Ex_in, cMul(J22, Ey_in));

          Ex_out[px][py] = Ex_tmp;
          Ey_out[px][py] = Ey_tmp;
        }
      }
      return { Ex_out, Ey_out };
    }

    /********** Far-field with vector addition **********/
    function computeFarFieldVector(Ex_out, Ey_out, maxOrder) {
      const Nx = Ex_out.length;
      const Ny = Ex_out[0].length;
      const size = 2*maxOrder + 1;

      const intensities = [];
      for (let i = 0; i < size; i++) {
        intensities[i] = new Array(size).fill(0);
      }

      let maxI = 0;
      let I00  = 0;

      for (let mi = -maxOrder; mi <= maxOrder; mi++) {
        for (let ni = -maxOrder; ni <= maxOrder; ni++) {
          let Fx = c(0,0);
          let Fy = c(0,0);
          for (let px = 0; px < Nx; px++) {
            for (let py = 0; py < Ny; py++) {
              const phase = -2 * Math.PI * (mi*px/Nx + ni*py/Ny);
              const w = cExp(phase);
              Fx = cAdd(Fx, cMul(Ex_out[px][py], w));
              Fy = cAdd(Fy, cMul(Ey_out[px][py], w));
            }
          }
          const I = cAbs2(Fx) + cAbs2(Fy);
          const ii = mi + maxOrder;
          const jj = ni + maxOrder;
          intensities[ii][jj] = I;
          if (I > maxI) maxI = I;
          if (mi === 0 && ni === 0) I00 = I;
        }
      }

      if (maxI > 0) {
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            intensities[i][j] /= maxI;
          }
        }
        I00 /= maxI;
      }

      return { intensities, I00 };
    }

    /********** Heatmap + table **********/
    function drawHeatmap(intensities, canvas, maxOrder) {
      const ctx = canvas.getContext("2d");
      const size = intensities.length;
      const W = canvas.width;
      const H = canvas.height;
      ctx.clearRect(0,0,W,H);

      const cellW = W / size;
      const cellH = H / size;

      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const val = intensities[i][j];
          const v = Math.max(0, Math.min(1, val));
          const r = Math.floor(255 * v);
          const g = 0;
          const b = Math.floor(255 * (1 - v));
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(j*cellW, i*cellH, cellW, cellH);
        }
      }

      // indicate m=0 and n=0
      const z = maxOrder + 0.5;
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(z*cellW, 0);   ctx.lineTo(z*cellW, H);
      ctx.moveTo(0, z*cellH);   ctx.lineTo(W, z*cellH);
      ctx.stroke();
    }

    function createIntensityTable(intensities, maxOrder) {
      const size = intensities.length;
      let html = "<table><thead><tr><th>m \\ n</th>";
      for (let n = -maxOrder; n <= maxOrder; n++) {
        html += "<th>" + n + "</th>";
      }
      html += "</tr></thead><tbody>";
      for (let m = -maxOrder; m <= maxOrder; m++) {
        html += "<tr><th>" + m + "</th>";
        for (let n = -maxOrder; n <= maxOrder; n++) {
          const ii = m + maxOrder;
          const jj = n + maxOrder;
          html += "<td>" + intensities[ii][jj].toFixed(3) + "</td>";
        }
        html += "</tr>";
      }
      html += "</tbody></table>";
      return html;
    }

    /********** Main: runSimulation **********/
    function runSimulation() {
      const simStatus = document.getElementById("simStatus");
      const onAxisInfo = document.getElementById("onAxisInfo");
      const tblDiv = document.getElementById("intensityTableContainer");
      const canvas = document.getElementById("heatmap");

      simStatus.textContent = "";
      onAxisInfo.textContent = "";
      tblDiv.innerHTML = "";

      const pol = document.getElementById("inputPol").value;
      const maxOrder = parseInt(document.getElementById("maxOrder").value, 10);
      if (isNaN(maxOrder) || maxOrder < 0 || maxOrder > 12) {
        simStatus.textContent = "Choose |m|,|n| between 0 and 12.";
        return;
      }

      try {
        const library = getLibraryMatrices();
        const design  = getDesignMatrices();
        const { Ex_out, Ey_out } = computePillarFields(pol, library, design);
        const { intensities, I00 } = computeFarFieldVector(Ex_out, Ey_out, maxOrder);

        drawHeatmap(intensities, canvas, maxOrder);
        onAxisInfo.textContent = "(0,0) normalized intensity: " + I00.toFixed(3);
        tblDiv.innerHTML = createIntensityTable(intensities, maxOrder);
        simStatus.textContent = "Simulation complete.";
      } catch (err) {
        console.error(err);
        simStatus.textContent = "Error: " + err.message;
      }
    }

    document.getElementById("btnRun").addEventListener("click", runSimulation);
  </script>
</body>
</html>
