<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Metasurface Far-Field Simulator (10×10, Dim-Based)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 16px;
      background: #f5f5f5;
    }
    h1, h2, h3 {
      margin-top: 12px;
      margin-bottom: 6px;
    }
    .section {
      background: #ffffff;
      padding: 12px;
      margin-bottom: 16px;
      border-radius: 8px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }
    textarea {
      width: 100%;
      min-height: 80px;
      font-family: Consolas, monospace;
      font-size: 12px;
      white-space: pre;
    }
    label {
      font-weight: bold;
      display: block;
      margin-top: 6px;
      margin-bottom: 2px;
    }
    button {
      margin: 4px 4px 4px 0;
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #999;
      background: #eee;
      cursor: pointer;
    }
    button:hover {
      background: #ddd;
    }
    #heatmap {
      border: 1px solid #444;
      margin-top: 8px;
    }
    table {
      border-collapse: collapse;
      margin-top: 8px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 2px 4px;
      font-size: 11px;
      text-align: right;
    }
    .status {
      font-size: 12px;
      color: #333;
      margin-top: 4px;
    }
    .small-input {
      width: 80px;
    }
    .row-flex {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .col {
      flex: 1;
      min-width: 260px;
    }
    select {
      padding: 3px 6px;
      margin-left: 4px;
    }
  </style>
</head>
<body>
  <h1>Metasurface Far-Field Simulator (10×10 from Length/Width/Rotation)</h1>

  <!-- ===================== LIBRARY SECTION ===================== -->
  <div class="section">
    <h2>1. 400 nm Library (24×24) — φx, φy, Tx, Ty</h2>
    <p>Paste your <b>24×24</b> matrices (24 lines, each line 24 numbers separated by spaces) for the unit-cell library.</p>

    <div class="row-flex">
      <div class="col">
        <label for="libPhiX">φ<sub>x</sub> (Ex phase, rad, 24×24)</label>
        <textarea id="libPhiX" placeholder="row1: 24 numbers&#10;row2: 24 numbers&#10;..."></textarea>
      </div>
      <div class="col">
        <label for="libPhiY">φ<sub>y</sub> (Ey phase, rad, 24×24)</label>
        <textarea id="libPhiY"></textarea>
      </div>
    </div>

    <div class="row-flex">
      <div class="col">
        <label for="libTx">T<sub>x</sub> (Ex amplitude, 0–1, 24×24)</label>
        <textarea id="libTx"></textarea>
      </div>
      <div class="col">
        <label for="libTy">T<sub>y</sub> (Ey amplitude, 0–1, 24×24)</label>
        <textarea id="libTy"></textarea>
      </div>
    </div>

    <button id="btnSaveLibrary">Save Library to Firebase</button>
    <button id="btnLoadLibrary">Load Library from Firebase</button>
    <div id="libraryStatus" class="status"></div>
  </div>

  <!-- ===================== DESIGN SECTION ===================== -->
  <div class="section">
    <h2>2. Metasurface Design (10×10) — Length, Width, Rotation</h2>
    <p>Paste your <b>10×10</b> maps for each design parameter (10 lines, 10 numbers each).</p>

    <div class="row-flex">
      <div class="col">
        <label for="Lmap">Length L (nm, 10×10)</label>
        <textarea id="Lmap" placeholder="L in nm (e.g. between 50 and 280)"></textarea>
      </div>
      <div class="col">
        <label for="Wmap">Width W (nm, 10×10)</label>
        <textarea id="Wmap" placeholder="W in nm (e.g. between 50 and 280)"></textarea>
      </div>
    </div>

    <div class="row-flex">
      <div class="col">
        <label for="Rotmap">Rotation θ (degrees, 10×10)</label>
        <textarea id="Rotmap" placeholder="Rotation angle of each pillar (deg)"></textarea>
      </div>
    </div>

    <button id="btnSaveDesign">Save Design to Firebase</button>
    <button id="btnLoadDesign">Load Design from Firebase</button>
    <div id="designStatus" class="status"></div>
  </div>

  <!-- ===================== SIMULATION SECTION ===================== -->
  <div class="section">
    <h2>3. Simulation Settings & Run</h2>

    <label>
      Input polarization:
      <select id="inputPol">
        <option value="Ex">Ex</option>
        <option value="Ey">Ey</option>
        <option value="P45">+45°</option>
        <option value="M45">−45°</option>
        <option value="RCP">RCP</option>
        <option value="LCP">LCP</option>
      </select>
    </label>

    <label>
      Max diffraction order |m|, |n| (integer, ≤ 8 recommended):
      <input id="maxOrder" type="number" value="8" class="small-input">
    </label>

    <button id="btnRun">Run Simulation</button>
    <div id="simStatus" class="status"></div>
  </div>

  <!-- ===================== RESULTS SECTION ===================== -->
  <div class="section">
    <h2>4. Far-Field Results</h2>
    <p>Intensity is normalized so that the maximum over all (m,n) is 1. (0,0) order and a 2D heatmap are shown.</p>

    <div id="onAxisInfo" class="status"></div>
    <canvas id="heatmap" width="400" height="400"></canvas>
    <div id="intensityTableContainer"></div>
  </div>

  <!-- ===================== SCRIPTS ===================== -->
  <script type="module">
    /************* 1. Firebase Setup *************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

    // TODO: REPLACE with your actual Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyAGH2mKUzliyYytlxnqeJs_hPget2Uiik0",
  authDomain: "metasurface-9d919.firebaseapp.com",
  projectId: "metasurface-9d919",
  storageBucket: "metasurface-9d919.firebasestorage.app",
  messagingSenderId: "954226935548",
  appId: "1:954226935548:web:9ef1d9f09810fc3ae8f979",
    };

    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    const libDocRef    = doc(db, "metasurface", "library_400nm");
    const designDocRef = doc(db, "metasurface", "design_10x10_dim");

    /************* 2. Helper: Parse / Stringify Matrices *************/
    function parseMatrix(text, expectedRows, expectedCols) {
      const rows = text.trim().split(/\r?\n/).filter(r => r.trim().length > 0);
      if (rows.length !== expectedRows) {
        throw new Error(`Expected ${expectedRows} rows, got ${rows.length}`);
      }
      const mat = [];
      for (let i = 0; i < expectedRows; i++) {
        const parts = rows[i].trim().split(/[\s,]+/).filter(p => p.length > 0);
        if (parts.length !== expectedCols) {
          throw new Error(`Row ${i+1}: expected ${expectedCols} columns, got ${parts.length}`);
        }
        mat[i] = parts.map(Number);
      }
      return mat;
    }

    function matrixToText(mat) {
      return mat.map(row => row.join(" ")).join("\n");
    }

    /************* 3. Get / Set UI for Library & Design *************/
    function getLibraryFromUI() {
      const phiXText = document.getElementById("libPhiX").value;
      const phiYText = document.getElementById("libPhiY").value;
      const txText   = document.getElementById("libTx").value;
      const tyText   = document.getElementById("libTy").value;
      return { phiX: phiXText, phiY: phiYText, Tx: txText, Ty: tyText };
    }

    function setLibraryToUI(libObj) {
      if (!libObj) return;
      document.getElementById("libPhiX").value = libObj.phiX || "";
      document.getElementById("libPhiY").value = libObj.phiY || "";
      document.getElementById("libTx").value   = libObj.Tx   || "";
      document.getElementById("libTy").value   = libObj.Ty   || "";
    }

    function getDesignFromUI() {
      return {
        Lmap:   document.getElementById("Lmap").value,
        Wmap:   document.getElementById("Wmap").value,
        Rotmap: document.getElementById("Rotmap").value
      };
    }

    function setDesignToUI(desObj) {
      if (!desObj) return;
      document.getElementById("Lmap").value   = desObj.Lmap   || "";
      document.getElementById("Wmap").value   = desObj.Wmap   || "";
      document.getElementById("Rotmap").value = desObj.Rotmap || "";
    }

    /************* 4. Firebase Save / Load *************/
    async function saveLibraryToFirebase() {
      const statusEl = document.getElementById("libraryStatus");
      statusEl.textContent = "Saving library to Firebase...";
      try {
        const lib = getLibraryFromUI();
        await setDoc(libDocRef, lib);
        statusEl.textContent = "Library saved successfully.";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error saving library: " + err.message;
      }
    }

    async function loadLibraryFromFirebase() {
      const statusEl = document.getElementById("libraryStatus");
      statusEl.textContent = "Loading library from Firebase...";
      try {
        const snap = await getDoc(libDocRef);
        if (!snap.exists()) {
          statusEl.textContent = "No library found in Firebase (metasurface/library_400nm).";
          return;
        }
        const data = snap.data();
        setLibraryToUI(data);
        statusEl.textContent = "Library loaded.";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error loading library: " + err.message;
      }
    }

    async function saveDesignToFirebase() {
      const statusEl = document.getElementById("designStatus");
      statusEl.textContent = "Saving design to Firebase...";
      try {
        const design = getDesignFromUI();
        await setDoc(designDocRef, design);
        statusEl.textContent = "Design saved successfully.";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error saving design: " + err.message;
      }
    }

    async function loadDesignFromFirebase() {
      const statusEl = document.getElementById("designStatus");
      statusEl.textContent = "Loading design from Firebase...";
      try {
        const snap = await getDoc(designDocRef);
        if (!snap.exists()) {
          statusEl.textContent = "No design found in Firebase (metasurface/design_10x10_dim).";
          return;
        }
        const data = snap.data();
        setDesignToUI(data);
        statusEl.textContent = "Design loaded.";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error loading design: " + err.message;
      }
    }

    document.getElementById("btnSaveLibrary").addEventListener("click", saveLibraryToFirebase);
    document.getElementById("btnLoadLibrary").addEventListener("click", loadLibraryFromFirebase);
    document.getElementById("btnSaveDesign").addEventListener("click", saveDesignToFirebase);
    document.getElementById("btnLoadDesign").addEventListener("click", loadDesignFromFirebase);

    /************* 5. Physics Helpers *************/
    // Get 24×24 library matrices from textareas
    function getLibraryMatrices() {
      const phiX = parseMatrix(document.getElementById("libPhiX").value, 24, 24);
      const phiY = parseMatrix(document.getElementById("libPhiY").value, 24, 24);
      const Tx   = parseMatrix(document.getElementById("libTx").value,   24, 24);
      const Ty   = parseMatrix(document.getElementById("libTy").value,   24, 24);
      return { phiX, phiY, Tx, Ty };
    }

    // Get 10×10 design: L, W, theta (deg)
    function getDesignMatrices() {
      const Lmap   = parseMatrix(document.getElementById("Lmap").value,   10, 10);
      const Wmap   = parseMatrix(document.getElementById("Wmap").value,   10, 10);
      const Rotmap = parseMatrix(document.getElementById("Rotmap").value, 10, 10);
      return { Lmap, Wmap, Rotmap };
    }

    // Map a (L_nm, W_nm) to nearest library indices (0..23)
    function libIndexFromDimensions(L_nm, W_nm) {
      // library grid 50:10:280
      let i = Math.round((L_nm - 50) / 10);
      let j = Math.round((W_nm - 50) / 10);
      if (i < 0) i = 0;
      if (i > 23) i = 23;
      if (j < 0) j = 0;
      if (j > 23) j = 23;
      return { i, j };
    }

    // Input Jones vector for chosen polarization
    function inputJonesVector(pol) {
      const invSqrt2 = 1 / Math.sqrt(2);
      switch (pol) {
        case "Ex":  return { Ex: 1, Ey: 0 };
        case "Ey":  return { Ex: 0, Ey: 1 };
        case "P45": return { Ex:  invSqrt2, Ey:  invSqrt2 };      // (1,1)/√2
        case "M45": return { Ex:  invSqrt2, Ey: -invSqrt2 };      // (1,-1)/√2
        case "RCP": return { Ex:  invSqrt2, Ey: -invSqrt2 * 1j }; // (1,-i)/√2
        case "LCP": return { Ex:  invSqrt2, Ey:  invSqrt2 * 1j }; // (1,i)/√2
        default:    return { Ex: 1, Ey: 0 };
      }
    }

    // But JS has no native i -> so we represent complex as {re, im}
    function c(re, im) { return { re, im }; }
    function cAdd(a, b) { return { re: a.re + b.re, im: a.im + b.im }; }
    function cMul(a, b) { return { re: a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re }; }
    function cExp(iPhi) { return { re: Math.cos(iPhi), im: Math.sin(iPhi) }; }
    function cAbs2(a) { return a.re*a.re + a.im*a.im; }

    /************* 6. Build Per-Pillar Jones Matrix & Output Field *************/
    function computePillarFields(pol, library, design) {
      const Nx = 10;
      const Ny = 10;

      const { phiX, phiY, Tx, Ty } = library;
      const { Lmap, Wmap, Rotmap } = design;

      // Input Jones vector for chosen polarization
      let Jin;
      const invSqrt2 = 1/Math.sqrt(2);
      switch (pol) {
        case "Ex":  Jin = [c(1,0), c(0,0)]; break;
        case "Ey":  Jin = [c(0,0), c(1,0)]; break;
        case "P45": Jin = [c(invSqrt2,0), c(invSqrt2,0)]; break;
        case "M45": Jin = [c(invSqrt2,0), c(-invSqrt2,0)]; break;
        case "RCP": Jin = [c(invSqrt2,0), c(0,-invSqrt2)]; break; // (1,-i)/√2
        case "LCP": Jin = [c(invSqrt2,0), c(0, invSqrt2)]; break; // (1, i)/√2
        default:    Jin = [c(1,0), c(0,0)];
      }

      // Output fields at each pillar: Ex_out(px,py), Ey_out(px,py)
      const Ex_out = [];
      const Ey_out = [];
      for (let px = 0; px < Nx; px++) {
        Ex_out[px] = new Array(Ny);
        Ey_out[px] = new Array(Ny);
        for (let py = 0; py < Ny; py++) {
          const L_nm = Lmap[px][py];
          const W_nm = Wmap[px][py];
          const theta_deg = Rotmap[px][py];
          const { i, j } = libIndexFromDimensions(L_nm, W_nm);

          const phx = phiX[i][j];
          const phy = phiY[i][j];
          const tx  = Tx[i][j];
          const ty  = Ty[i][j];

          // Base Jones matrix (aligned to x,y): diag(tx e^{iφx}, ty e^{iφy})
          const jxx = cExp(phx); jxx.re *= tx; jxx.im *= tx;
          const jyy = cExp(phy); jyy.re *= ty; jyy.im *= ty;

          const theta = theta_deg * Math.PI / 180;
          const cth = Math.cos(theta);
          const sth = Math.sin(theta);

          // Rotation matrices:
          // R(θ) = [[cth, -sth],[sth, cth]]
          // J = R(-θ) * diag(jxx, jyy) * R(θ)
          const cthm = Math.cos(-theta);
          const sthm = Math.sin(-theta);

          // First M = diag(jxx,jyy)*R(θ)
          const r11 = cth,  r12 = -sth;
          const r21 = sth,  r22 =  cth;

          const m11 = cMul(jxx, c(r11,0));
          const m12 = cMul(jxx, c(r12,0));
          const m21 = cMul(jyy, c(r21,0));
          const m22 = cMul(jyy, c(r22,0));

          // J = R(-θ)*M
          const rm11 = c(cthm,0), rm12 = c(-sthm,0);
          const rm21 = c(sthm,0), rm22 = c(cthm,0);

          function cAddMul(a,b,c_) {
            // a*b + c_
            const prod = cMul(a,b);
            return cAdd(prod, c_);
          }

          const J11 = cAddMul(rm11, m11, cMul(rm12, m21));
          const J12 = cAddMul(rm11, m12, cMul(rm12, m22));
          const J21 = cAddMul(rm21, m11, cMul(rm22, m21));
          const J22 = cAddMul(rm21, m12, cMul(rm22, m22));

          // E_out = J * Jin
          const Ex_in = Jin[0];
          const Ey_in = Jin[1];
          const Ex_tmp = cAddMul(J11, Ex_in, cMul(J12, Ey_in));
          const Ey_tmp = cAddMul(J21, Ex_in, cMul(J22, Ey_in));

          Ex_out[px][py] = Ex_tmp;
          Ey_out[px][py] = Ey_tmp;
        }
      }
      return { Ex_out, Ey_out };
    }

    /************* 7. Far-Field from Per-Pillar Fields *************/
    function computeFarFieldVector(Ex_out, Ey_out, maxOrder) {
      const Nx = Ex_out.length;
      const Ny = Ex_out[0].length;
      const size = 2 * maxOrder + 1;

      const intensities = [];
      for (let i = 0; i < size; i++) {
        intensities[i] = new Array(size).fill(0);
      }

      let maxI = 0;
      let I00  = 0;

      for (let mi = -maxOrder; mi <= maxOrder; mi++) {
        for (let ni = -maxOrder; ni <= maxOrder; ni++) {
          let Fx = c(0,0);
          let Fy = c(0,0);
          for (let px = 0; px < Nx; px++) {
            for (let py = 0; py < Ny; py++) {
              const phase = -2 * Math.PI * (mi * px / Nx + ni * py / Ny);
              const w = cExp(phase);
              Fx = cAdd(Fx, cMul(Ex_out[px][py], w));
              Fy = cAdd(Fy, cMul(Ey_out[px][py], w));
            }
          }
          const I = cAbs2(Fx) + cAbs2(Fy);
          const ii = mi + maxOrder;
          const jj = ni + maxOrder;
          intensities[ii][jj] = I;
          if (I > maxI) maxI = I;
          if (mi === 0 && ni === 0) I00 = I;
        }
      }

      if (maxI > 0) {
        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            intensities[i][j] /= maxI;
          }
        }
        I00 /= maxI;
      }

      return { intensities, I00, maxI };
    }

    /************* 8. Visualization *************/
    function drawHeatmap(intensities, canvas, maxOrder) {
      const ctx = canvas.getContext("2d");
      const size = intensities.length;
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      const cellW = w / size;
      const cellH = h / size;

      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const val = intensities[i][j];
          const cval = Math.max(0, Math.min(1, val));
          const r = Math.floor(255 * cval);
          const g = 0;
          const b = Math.floor(255 * (1 - cval));
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(j * cellW, i * cellH, cellW, cellH);
        }
      }

      // Draw axes lines at m=0 and n=0
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1;
      const zeroIndex = maxOrder + 0.5;
      ctx.beginPath();
      ctx.moveTo(zeroIndex * cellW, 0);
      ctx.lineTo(zeroIndex * cellW, h);
      ctx.moveTo(0, zeroIndex * cellH);
      ctx.lineTo(w, zeroIndex * cellH);
      ctx.stroke();
    }

    function createIntensityTable(intensities, maxOrder) {
      const size = intensities.length;
      let html = "<table><thead><tr><th>m \\ n</th>";
      for (let n = -maxOrder; n <= maxOrder; n++) {
        html += `<th>${n}</th>`;
      }
      html += "</tr></thead><tbody>";

      for (let m = -maxOrder; m <= maxOrder; m++) {
        html += `<tr><th>${m}</th>`;
        for (let n = -maxOrder; n <= maxOrder; n++) {
          const ii = m + maxOrder;
          const jj = n + maxOrder;
          const val = intensities[ii][jj];
          html += `<td>${val.toFixed(3)}</td>`;
        }
        html += "</tr>";
      }
      html += "</tbody></table>";
      return html;
    }

    /************* 9. Run Simulation *************/
    function runSimulation() {
      const simStatus = document.getElementById("simStatus");
      simStatus.textContent = "";
      document.getElementById("onAxisInfo").textContent = "";
      document.getElementById("intensityTableContainer").innerHTML = "";

      const canvas = document.getElementById("heatmap");
      const pol = document.getElementById("inputPol").value;
      const maxOrder = parseInt(document.getElementById("maxOrder").value, 10);

      if (isNaN(maxOrder) || maxOrder < 0 || maxOrder > 12) {
        simStatus.textContent = "Please choose maxOrder between 0 and 12.";
        return;
      }

      try {
        const library = getLibraryMatrices();
        const design  = getDesignMatrices();

        const { Ex_out, Ey_out } = computePillarFields(pol, library, design);
        const { intensities, I00 } = computeFarFieldVector(Ex_out, Ey_out, maxOrder);

        drawHeatmap(intensities, canvas, maxOrder);
        document.getElementById("onAxisInfo").textContent =
          `(0,0) order normalized intensity: ${I00.toFixed(3)}`;

        const tableHTML = createIntensityTable(intensities, maxOrder);
        document.getElementById("intensityTableContainer").innerHTML = tableHTML;

        simStatus.textContent = "Simulation complete.";
      } catch (err) {
        console.error(err);
        simStatus.textContent = "Error in simulation: " + err.message;
      }
    }

    document.getElementById("btnRun").addEventListener("click", runSimulation);
  </script>
</body>
</html>
