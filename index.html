<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Metasurface Far-Field Simulator (10x10, 6 orders)</title>
<style>
  body { font-family: Arial, sans-serif; margin: 10px; }
  textarea { width: 100%; height: 120px; font-family: Consolas, monospace; }
  .section { border: 1px solid #ccc; padding: 8px; margin-bottom: 8px; }
  .section h2 { margin-top: 0; font-size: 16px; }
  label { font-weight: bold; }
  pre { background:#f7f7f7; padding:8px; }
</style>
</head>
<body>

<h1>Metasurface Far-Field Simulator (10×10, 6 diffraction orders)</h1>

<div class="section">
  <h2>1. Library data (24×24 each)</h2>
  <p>Paste your 24×24 matrices exactly as in MATLAB (rows separated by new line, columns by space/comma).</p>
  <label>phiX (Ex phase in radians, 24×24)</label>
  <textarea id="phiXText"></textarea>

  <label>phiY (Ey phase in radians, 24×24)</label>
  <textarea id="phiYText"></textarea>

  <label>Tx (Ex transmission amplitude 0–1, 24×24)</label>
  <textarea id="TxText"></textarea>

  <label>Ty (Ey transmission amplitude 0–1, 24×24)</label>
  <textarea id="TyText"></textarea>
</div>

<div class="section">
  <h2>2. Metasurface design (10×10)</h2>
  <p>Paste 10×10 matrices for L, W, and rotation θ (degrees). L and W must be between 50 and 280 nm in 10 nm steps.</p>
  <label>L (nm, 10×10)</label>
  <textarea id="LdesignText"></textarea>

  <label>W (nm, 10×10)</label>
  <textarea id="WdesignText"></textarea>

  <label>θ (degrees, 10×10)</label>
  <textarea id="thetaText"></textarea>
</div>

<div class="section">
  <h2>3. Input polarization</h2>
  <select id="polSelect">
    <option value="Ex">Ex (1, 0)</option>
    <option value="Ey">Ey (0, 1)</option>
    <option value="+45">+45° (1, 1)/√2</option>
    <option value="-45">-45° (1, -1)/√2</option>
    <option value="RCP">RCP (1, -i)/√2</option>
    <option value="LCP">LCP (1, +i)/√2</option>
  </select>
  <button onclick="runSimulation()">Simulate</button>
</div>

<div class="section">
  <h2>4. Results</h2>
  <pre id="output"></pre>
</div>

<script>
// ---------- Complex number utilities ----------
function C(re, im) { return {re: re, im: im}; }
function cAdd(a, b) { return {re: a.re + b.re, im: a.im + b.im}; }
function cSub(a, b) { return {re: a.re - b.re, im: a.im - b.im}; }
function cMul(a, b) {
  return {re: a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re};
}
function cMulReal(a, r) { return {re: a.re*r, im: a.im*r}; }
function cAbs2(a) { return a.re*a.re + a.im*a.im; }
function cExpReal(phi) { return {re: Math.cos(phi), im: Math.sin(phi)}; }

// ---------- Parsing helpers ----------
function parseMatrix(text, rows, cols) {
  const lines = text.trim().split(/\n+/);
  if (lines.length < rows) {
    throw new Error("Not enough rows. Expected " + rows + ", got " + lines.length);
  }
  const M = [];
  for (let i = 0; i < rows; i++) {
    const tokens = lines[i].trim().split(/[\s,]+/).filter(t => t.length > 0);
    if (tokens.length < cols) {
      throw new Error("Row " + (i+1) + ": expected " + cols + " columns, got " + tokens.length);
    }
    const row = [];
    for (let j = 0; j < cols; j++) {
      row.push(parseFloat(tokens[j]));
    }
    M.push(row);
  }
  return M;
}

// map L or W between 50..280 (step 10) to index 0..23
function dimToIndex(val) {
  let idx = Math.round((val - 50) / 10);
  if (idx < 0) idx = 0;
  if (idx > 23) idx = 23;
  return idx;
}

// Jones matrix for rotated pillar from library data
function jonesFromLib(tEx, tEy, thetaRad) {
  const c = Math.cos(thetaRad);
  const s = Math.sin(thetaRad);
  const c2 = c*c;
  const s2 = s*s;
  const cs = c*s;

  // Jxx = a c^2 + b s^2
  const Jxx = cAdd( cMulReal(tEx, c2), cMulReal(tEy, s2) );
  // Jxy = (b - a) c s
  const diff = cSub(tEy, tEx);
  const Jxy = cMulReal(diff, cs);
  const Jyx = {re: Jxy.re, im: Jxy.im};
  // Jyy = a s^2 + b c^2
  const Jyy = cAdd( cMulReal(tEx, s2), cMulReal(tEy, c2) );

  return {Jxx, Jxy, Jyx, Jyy};
}

// ---------- Main simulation ----------
function runSimulation() {
  const out = document.getElementById("output");
  out.textContent = "Running...\n";

  try {
    // 1) Parse library (24×24)
    const phiX = parseMatrix(document.getElementById("phiXText").value, 24, 24);
    const phiY = parseMatrix(document.getElementById("phiYText").value, 24, 24);
    const Tx   = parseMatrix(document.getElementById("TxText").value,   24, 24);
    const Ty   = parseMatrix(document.getElementById("TyText").value,   24, 24);

    // 2) Parse design (10×10)
    const Ldes = parseMatrix(document.getElementById("LdesignText").value, 10, 10);
    const Wdes = parseMatrix(document.getElementById("WdesignText").value, 10, 10);
    const Th   = parseMatrix(document.getElementById("thetaText").value,   10, 10);

    const Nx = 10, Ny = 10;

    // 3) Input polarization vector
    const pol = document.getElementById("polSelect").value;
    let Einx, Einy;
    const invSqrt2 = 1/Math.sqrt(2);
    if (pol === "Ex") {
      Einx = C(1,0); Einy = C(0,0);
    } else if (pol === "Ey") {
      Einx = C(0,0); Einy = C(1,0);
    } else if (pol === "+45") {
      Einx = C(invSqrt2,0); Einy = C(invSqrt2,0);
    } else if (pol === "-45") {
      Einx = C(invSqrt2,0); Einy = C(-invSqrt2,0);
    } else if (pol === "RCP") {
      Einx = C(invSqrt2,0); Einy = C(0,-invSqrt2); // (1, -i)/√2
    } else if (pol === "LCP") {
      Einx = C(invSqrt2,0); Einy = C(0, invSqrt2); // (1, +i)/√2
    }

    // 4) Diffraction orders of interest
    const orders = [
      {name: "(+2, 0)", m:  2, n:  0},
      {name: "(-2, 0)", m: -2, n:  0},
      {name: "(0, +2)", m:  0, n:  2},
      {name: "(0, -2)", m:  0, n: -2},
      {name: "(+2, +2)", m:  2, n:  2},
      {name: "(-2, -2)", m: -2, n: -2}
    ];

    // accumulators for each order
    const amps = orders.map(() => ({
      Ex: C(0,0),
      Ey: C(0,0)
    }));

    // 5) Loop over pillars
    for (let px = 0; px < Nx; px++) {
      for (let py = 0; py < Ny; py++) {

        const Lnm = Ldes[px][py];
        const Wnm = Wdes[px][py];
        const thetaDeg = Th[px][py];
        const thetaRad = thetaDeg * Math.PI / 180.0;

        const iL = dimToIndex(Lnm);
        const iW = dimToIndex(Wnm);

        const phx = phiX[iL][iW];
        const phy = phiY[iL][iW];
        const txAmp = Tx[iL][iW];
        const tyAmp = Ty[iL][iW];

        // complex transmissions in local frame
        const tEx = C(txAmp * Math.cos(phx), txAmp * Math.sin(phx));
        const tEy = C(tyAmp * Math.cos(phy), tyAmp * Math.sin(phy));

        // Jones matrix in lab frame
        const J = jonesFromLib(tEx, tEy, thetaRad);

        // field after this pillar
        const Ex_out = cAdd( cMul(J.Jxx, Einx), cMul(J.Jxy, Einy) );
        const Ey_out = cAdd( cMul(J.Jyx, Einx), cMul(J.Jyy, Einy) );

        // add contribution to each diffraction order
        for (let k = 0; k < orders.length; k++) {
          const m = orders[k].m;
          const n = orders[k].n;
          const phase = -2*Math.PI*( m*px/Nx + n*py/Ny );
          const w = cExpReal(phase);
          amps[k].Ex = cAdd(amps[k].Ex, cMul(Ex_out, w));
          amps[k].Ey = cAdd(amps[k].Ey, cMul(Ey_out, w));
        }
      }
    }

    // 6) Compute intensities
    const intensities = [];
    let Imax = 0;
    for (let k = 0; k < orders.length; k++) {
      const I = cAbs2(amps[k].Ex) + cAbs2(amps[k].Ey);
      intensities.push(I);
      if (I > Imax) Imax = I;
    }

    // 7) Print results
    let txt = "";
    txt += "Input polarization: " + pol + "\n\n";
    txt += "Order    Raw Intensity    Normalized (I/I_max)\n";
    txt += "----------------------------------------------\n";
    for (let k = 0; k < orders.length; k++) {
      const I = intensities[k];
      const norm = (Imax > 0) ? (I / Imax) : 0;
      txt += `${orders[k].name.padEnd(9)}  ${I.toExponential(3).padStart(13)}      ${norm.toFixed(3)}\n`;
    }

    out.textContent = txt;

  } catch (e) {
    out.textContent = "Error: " + e.message;
  }
}
</script>
</body>
</html>
